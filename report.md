# my_devops_project_1

- [my\_devops\_project\_1](#my_devops_project_1)
  - [1. Установка ОС](#1-установка-ос)
    - [Установить Ubuntu 20.04 Server LTS без графического интерфейса](#установить-ubuntu-2004-server-lts-без-графического-интерфейса)
  - [2. Создание пользователя](#2-создание-пользователя)
    - [Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен быть добавлен в группу `adm`](#создать-пользователя-отличного-от-пользователя-который-создавался-при-установке-пользователь-должен-быть-добавлен-в-группу-adm)
  - [3. Настройка сети ОС](#3-настройка-сети-ос)
    - [Задать название машины вида user-1](#задать-название-машины-вида-user-1)
    - [Установить временную зону, соответствующую вашему текущему местоположению](#установить-временную-зону-соответствующую-вашему-текущему-местоположению)
    - [Вывести названия сетевых интерфейсов с помощью консольной команды](#вывести-названия-сетевых-интерфейсов-с-помощью-консольной-команды)
    - [Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера](#используя-консольную-команду-получить-ip-адрес-устройства-на-котором-вы-работаете-от-dhcp-сервера)
    - [Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw)](#определить-и-вывести-на-экран-внешний-ip-адрес-шлюза-ip-и-внутренний-ip-адрес-шлюза-он-же-ip-адрес-по-умолчанию-gw)
    - [Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8)](#задать-статичные-заданные-вручную-а-не-полученные-от-dhcp-сервера-настройки-ip-gw-dns-использовать-публичный-dns-серверы-например-1111-или-8888)
    - [Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте](#перезагрузить-виртуальную-машину-убедиться-что-статичные-сетевые-настройки-ip-gw-dns-соответствуют-заданным-в-предыдущем-пункте)
  - [4. Обновление ОС](#4-обновление-ос)
    - [Обновить системные пакеты до последней на момент выполнения задания версии](#обновить-системные-пакеты-до-последней-на-момент-выполнения-задания-версии)
  - [5. Использование команды sudo](#5-использование-команды-sudo)
    - [Разрешить пользователю, созданному в Part 2, выполнять команду sudo](#разрешить-пользователю-созданному-в-part-2-выполнять-команду-sudo)
  - [6. Установка и настройка службы времени](#6-установка-и-настройка-службы-времени)
    - [Настроить службу автоматической синхронизации времени](#настроить-службу-автоматической-синхронизации-времени)
  - [7. Установка и использование текстовых редакторов.](#7-установка-и-использование-текстовых-редакторов)
    - [Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)](#установить-текстовые-редакторы-vim--любые-два-по-желанию-nano-mcedit-joe-и-тд)
    - [Используя каждый из трех выбранных редакторов, создайте файл test\_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений](#используя-каждый-из-трех-выбранных-редакторов-создайте-файл-test_xtxt-где-x----название-редактора-в-котором-создан-файл-напишите-в-нём-свой-никнейм-закройте-файл-с-сохранением-изменений)
    - [Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений](#используя-каждый-из-трех-выбранных-редакторов-откройте-файл-на-редактирование-отредактируйте-файл-заменив-никнейм-на-строку-21-school-21-закройте-файл-без-сохранения-изменений)
    - [Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое](#используя-каждый-из-трех-выбранных-редакторов-отредактируйте-файл-ещё-раз-по-аналогии-с-предыдущим-пунктом-а-затем-освойте-функции-поиска-по-содержимому-файла-слово-и-замены-слова-на-любое-другое)
  - [8. Установка и базовая настройка сервиса sshd.](#8-установка-и-базовая-настройка-сервиса-sshd)
    - [Установить службу sshd](#установить-службу-sshd)
    - [Добавить автостарт службы при загрузке системы](#добавить-автостарт-службы-при-загрузке-системы)
    - [Перенастроить службу SSHd на порт 2022](#перенастроить-службу-sshd-на-порт-2022)
    - [Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи](#используя-команду-ps-показать-наличие-процесса-sshd-для-этого-к-команде-нужно-подобрать-ключи)
    - [Перезагрузить систему](#перезагрузить-систему)
    - [Вывод команды `netstat -tan`](#вывод-команды-netstat--tan)
  - [9. Установка и использование утилит top, htop](#9-установка-и-использование-утилит-top-htop)
    - [Установить и запустить утилиты top и htop.](#установить-и-запустить-утилиты-top-и-htop)
    - [Запуск программы](#запуск-программы)
  - [10. Использование утилиты fdisk](#10-использование-утилиты-fdisk)
    - [Запустить команду \_\_fdisk -l](#запустить-команду-__fdisk--l)
  - [11. Использование утилиты df](#11-использование-утилиты-df)
    - [Запустить команду df.](#запустить-команду-df)
  - [12. Использование утилиты du](#12-использование-утилиты-du)
    - [Запустить команду du](#запустить-команду-du)
    - [Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)](#вывести-размер-папок-home-var-varlog-в-байтах-в-человекочитаемом-виде)
    - [Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя \*)](#вывести-размер-всего-содержимого-в-varlog-не-общее-а-каждого-вложенного-элемента-используя-)
  - [13. Установка и использование утилиты ncdu](#13-установка-и-использование-утилиты-ncdu)
    - [Установить утилиту ncdu](#установить-утилиту-ncdu)
    - [Вывести размер папок /home, /var, /var/log](#вывести-размер-папок-home-var-varlog)
  - [14. Работа с системными журналами](#14-работа-с-системными-журналами)
    - [Открыть для просмотра:](#открыть-для-просмотра)
    - [Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему](#написать-в-отчёте-время-последней-успешной-авторизации-имя-пользователя-и-метод-входа-в-систему)
    - [Перезапустить службу sshd](#перезапустить-службу-sshd)
    - [Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах)](#вставить-в-отчёт-скрин-с-сообщением-о-рестарте-службы-искать-в-логах)
  - [15. Использование планировщика заданий CRON](#15-использование-планировщика-заданий-cron)
    - [Используя планировщик заданий, запустите команду uptime через каждые 2 минуты](#используя-планировщик-заданий-запустите-команду-uptime-через-каждые-2-минуты)
    - [Настройка cron](#настройка-cron)

***
## 1. Установка ОС

### Установить Ubuntu 20.04 Server LTS без графического интерфейса

- Определяю версию Ubuntu, выполнив команду `cat /etc/issue.`

![Версия Ubuntu 20.04](/screenshots/part1.PNG)


***
## 2. Создание пользователя

### Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен быть добавлен в группу `adm`

- С помощью команды `sudo useradd -G adm user_1 `, создаю пользователя __user_1__ .

![команда sudo useradd -G adm user_1](/screenshots/part2_1.PNG)

- Новый пользователь должен быть в выводе команды `cat /etc/passwd`

![команда cat /etc/passwd](/screenshots/part2_2.PNG)


***
## 3. Настройка сети ОС

### Задать название машины вида user-1

- С помощью команды `sudo hostnamectl set-hostname user-1`, задаю имя машины __user-1__.

![команда sudo hostnamectl set-hostname user-1](/screenshots/part3_1.PNG)

### Установить временную зону, соответствующую вашему текущему местоположению

- С помощью команды  `sudo timedatectl set-timezone Europe/Moscow`, устанавливаю временную зону.
- Текущую дату, время и временную зону проверяю с помощью команды `timedatectl`. Так же можно использовать команду `ls -l /etc/localtime`.

![вывод текущей временой зоны Europe/Moscow](/screenshots/part3_2.PNG)

### Вывести названия сетевых интерфейсов с помощью консольной команды

- Oбъяснение наличия интерфейса lo.
  - lo - метод передачи цифровых потоков данных от их источника и обратно к тому же источнику без специальной обработки или модификаций, имеющий виртуальный интерфейс, который ограничен только производительностью системы. Используется как средство межпроцессного обмена информацией только для локальных процессов, как дополнительное средство в исправлении проблем физического соединения.
- Для вывода сетевого интерфейса __lo__ использую команду `ip link show`. Также можно использовать команды `ip addr` или `ip -s link`.

![вывод lo командой ip link show](/screenshots/part3_3.PNG)

### Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера

- Расшифровка DHCP.
  - DHCP (англ. Dynamic Host Configuration Protocol — протокол динамической настройки узла) — протокол прикладного уровня модели TCP/IP, служит для автоматизации назначения IP-адреса клиенту. Он широко используется в современных сетях, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. Данный протокол работает по модели «клиент-сервер». Для автоматической конфигурации компьютер-клиент на этапе конфигурации сетевого устройства обращается к так называемому серверу DHCP и получает от него нужные параметры. Сетевой администратор может задать диапазон адресов, распределяемых сервером среди компьютеров. Это позволяет избежать ручной настройки компьютеров сети и уменьшает количество ошибок. Протокол DHCP используется в большинстве сетей TCP/IP.
- С помощью команды `ip a` узнаю __ip адрес__. Также можно использовать команды `ip add`

![вывод команды ip a](/screenshots/part3_4.PNG)

### Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw)

- С помощью команд `netstat -r -n` и `ip route` определяю ip-адреса.

![команда netstat -r -n и команда ip route](/screenshots/part3_5.PNG)

### Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8)

- Узнаю адрес шлюза с помощью команды ` ip route show match 0/0`. Мой ip адрес шлюза __10.0.2.15__.

В локальных сетях адреса шлюза находятся в следующих диапазонах:

- `10.0.0.0 – 10.255.255.255`
- `172.16.0.0 – 172.31.255.255`
- `192.168.0.0 – 192.168.255.255`
    
В моем случае подходит первый вариант

- Использую команду `sudo vim /etc/netplan/00-installer-config.yaml`. С помощью редактора __vim__ вношу изменения

![редактор vim .yaml](/screenshots/part3_6.PNG)

- Сохраняю изменения с помощью команды `sudo netplan apply`. Перезагружаю командой `sudo reboot`, проверяю ip адрес командой `ip a`.

![текущий ip адрес](/screenshots/part3_7.PNG)

### Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте

- Перезагружаю командой `sudo reboot`, используя команду `cd /etc/netplan`. Оказываюсь в директории __netplan__. Использую команду `systemd-resolve --status | grep -i 'DNS Server' -A2` (флаг `-i` для игнорирования регистра).

![вывод публичного DNS сервера](/screenshots/part3_8.PNG)

-  Успешно пингую удаленные хосты __1.1.1.1__ и __ya.ru__ с помощью команд `ping 1.1.1.1` и `ping ya.ru`.

![ping удаленных хостов](/screenshots/part3_9.PNG)


***
## 4. Обновление ОС

### Обновить системные пакеты до последней на момент выполнения задания версии

- Ввожу команду `sudo apt-get update`, которая обновит информацию о пакетах, содержащихся в репозиториях. Затем ввожу команду  `sudo apt-get dist-upgrade` для обновления последней версии.

![обновления отсутсвуют](/screenshots/part4.PNG)


***
## 5. Использование команды sudo

### Разрешить пользователю, созданному в Part 2, выполнять команду sudo

- Истинное назначение команды `sudo`.
  - `sudo` (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы. Основная идея — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач. Программа поставляется для большинства UNIX и UNIX-подобных операционных систем.
  Команда sudo предоставляет возможность пользователям выполнять команды от имени суперпользователя `root`, либо других пользователей. Правила, используемые __`sudo`__ для принятия решения о предоставлении доступа, находятся в файле `/etc/sudoers` (для редактирования файла можно использовать специальный редактор __visudo__, запускаемый из командной строки без параметров, в том числе без указания пути к файлу); язык их написания и примеры использования подробно изложены в `man sudoers`.
  В большинстве случаев грамотная настройка __`sudo`__ делает небезопасную работу от имени суперпользователя ненужной. Все действия оказываются выполнимы из-под аккаунта пользователя, которому разрешено использовать __`sudo`__ без ограничений. Имеется возможность запрещать и разрешать определённым пользователям или группам выполнение конкретного набора программ, а также разрешить выполнение определённых программ без необходимости ввода своего пароля.
- Поменять hostname ОС от имени пользователя, созданного в пункте Part 2 (используя sudo).
  - Выполняю перезагрузку командой `sudo reboot`; 
  - Создаю нового пользователя командой `sudo adduser test-user`;
  - Создаю пароль для нового пользователя. Остальные параметры пропускаю с помощью `Enter`;
  - Добавляю пользователя `test-user` в группу __sudo__ командой `sudo usermod -aG test-user`;
  - Переключаю пользователя на `test-user` командой `su test-user`;
  - Создаю новое имя машины командой ` sudo hostnamectl set-hostname user-2 `;
  - Перезагружаю систему командой `sudo reboot`.

![новый sudo пользователь](/screenshots/part5_1.PNG)

- Вставить скрин с изменённым hostname в отчёт.

![измененный hostname](/screenshots/part5_2.PNG)

***
## 6. Установка и настройка службы времени

### Настроить службу автоматической синхронизации времени

- __NTP__ (Network Time Protocol) — это сетевой протокол для синхронизации системного времени компьютера через сетевое соединение. NTP-клиент запрашивает время у общедоступного NTP-сервера, а затем использует ответ сервера для корректировки локальных часов. Ubuntu использует `ntpdate` и `ntpd`.
- __ntpdate__
Ubuntu стандартно устанавливается с `ntpdate` и будет запускать его при каждой загрузке один раз для установки времени по NTP серверу Ubuntu.
`ntpdate -s ntp.ubuntu.com`
- __ntpd__
Сервис NTP `ntpd` вычисляет уход ваших системных часов и постоянно подправляет их, благодаря чему не происходит сильных изменений, что может приводить к непоследовательности в журналах. Ценой этому небольшой расход мощности процессора и оперативной памяти, но для современного сервера это несущественно.
- __Установка__
Для установки `ntpd` из терминала ввожу команду `sudo apt-get install ntp`.

![install ntp Ubuntu](/screenshots/part6_1.PNG)

- Вывести время, часового пояса, в котором вы сейчас находитесь.
  - Использую команду `date`

![время, часовой пояс](/screenshots/part6_2.PNG)

- Вывод следующей команды должен содержать NTPSynchronized=yes: 
timedatectl show.
  - Перезагружаю систему `sudo reboot`;
  - Устанавливаю командой `sudo apt-get install ntp`;
  - устанавливаю утилиту командой`sudo apt install ntpdate`;
  - Команда синхронизаций: `ntpdate -s ntp.ubuntu.com`;
  - Открываю конфиг : `sudo nano /etc/systemd/timesyncd.conf`;
  - Изменяю сведения о NTP-сервере :

```bash
[Time]
- NTP=ntp.ubuntu.com
FallbackNTP=ntp.ubuntu.com
```
  - Обновляю данные: `sudo systemctl daemon-reload`;
  - Команда вывода: `sudo timedatectl show`.
  
  ![вывод NTPSynchronized=yes](/screenshots/part6_3.PNG)


***
## 7. Установка и использование текстовых редакторов.

### Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)

- Устанавливаю редактор MCEDIT командой `sudo apt install mc`

### Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений 

- Создаю файл __test_mcedit.txt__  с помощью команды `touch test_mcedit.txt`;
- Редактирую содержимое с помощью команды `mcedit test_mcedit.txt`;
- Прописав никнейм, сохраняю содержимое файла сочетанием клавиш __Fn+F2__;

![содержимое файла test_mcedit.txt](/screenshots/part7_1.PNG)

- Создаю файл __test_vim.txt__ командой `touch test_vim.txt`;
- Используя команду `vim test_vim.txt` для открытия редактора;
- Нажимаю __i__. Прописав нинейм, нажимаю кнопку __esc__, затем прописываю команду `:wq` для сохранения;

![сохраниение в редакторе vim](/screenshots/part7_2.PNG)

- Создаю файл __test_nano.txt__ командой `touch test_nano.txt`;
- Открываю редактор командой : `nano test_nano.txt`;
- Написав никнейм, сохраняю содержимое сочетанием клавиш __ctrl+O__, затем нажимаю __enter__.

![сохранение в nano](/screenshots/part7_3.PNG)

### Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений

- Oткрываю файл __test_mcedit.txt__ c помощью команды `mcedit test_mcedit.txt`;
- Редактирую содержимое файла, для выхода без сохранения использую клавиши __fn+F10__. На запрос __Сохранить при выходе?__ нажимаю __Нет__;

![Без сохранения mcedit](/screenshots/part7_4.PNG)

- Открываю файл __test_vim.txt__ c помощью команды `vim test_vim.txt`;

- Нажимаю __i__. Редактирую содержимое файла, затем, нажав __esc__, прописываю команду `:q!` для выхода без сохранения;

![выход без сохраения vim](/screenshots/part7_5.PNG)

- Открываю файл __test_nano.txt__ c помощью команды `nano test_nano.txt`;

- Редактирую содержимое файла, затем нажимаю сочетание клавиш __ctrl+X__. Появляется окно с вопросом __Save modified buffer?__. Нажимаю на кнопку __N__.

![без сохранения nano](/screenshots/part7_6.PNG)

### Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое

- В __Vim__ вы можете найти и заменить текст с помощью команды `:substitute ( :s )`.
Чтобы запускать команды в Vim, вы должны находиться в обычном режиме, который используется по умолчанию при запуске редактора. Чтобы вернуться в обычный режим из любого другого режима, просто нажмите клавишу __esc__.
Общая форма команды замены следующая: `:[range]s/{pattern}/{string}/[flags] [count]`
Команда ищет в каждой строке в `[range] {pattern}` и заменяет его `{string}`.
`[count]` — положительное целое число, умножающее команду.
Если не `[range] и [count]` , заменяется только шаблон, найденный в текущей строке. Текущая строка — это строка, в которой находится курсор.
Чтобы заменить все вхождения шаблона поиска в текущей строке, используется флаг __g__.
Если нужно найти и заменить шаблон во всем файле, использую процентный символ __%__ в качестве диапазона. Этот символ указывает диапазон от первой до последней строки файла.
- Использую команду для поиска в файле : `:s/lemuelge/`

![поиск текста vim](/screenshots/part7_7.PNG)

- Для замены найденного текста использую команду : `:s/lemuelge/kazan`

![изменения в поиске vim](/screenshots/part7_8.PNG)

- Поиск в __MCEDIT__ осуществляется с помощью сочентания клавиш __fn+F7__. Затем осуществляется ввод искомого слова в строке __Введите строку для поиска__.

Далее необходимо выбрать __Слово целиком__ (подсвечивается строка зеленым цветом и искомое слово желтым цветом).

![поиск в mcedit](/screenshots/part7_9.PNG)

- Чтобы заменить выделенное слово нужно вопользоваться сочетанием клавиш __fn+F4__. В появившемся окне в строке __Введите строку для поиска:__ ввожу слово которое хочу заменить, в строке __Введите текст для замены:__ вписываю слово или выражение для замены.

![замена в mcedit](/screenshots/part7_12.PNG)

- Затем нажимаю в окне на кнопку __<Дальше>__, которая переводит на окно с подтверждением замены. В данном окне необходимо нажать на кнопку __<Заменить>__ для подтверждения операции.

![замена и редактирование в mcedit](/screenshots/part7_10.PNG)

- После этого вижу на экране уже отредактированный текст.

![сохранение замены в mcedit](/screenshots/part7_11.PNG)

- Поиск и замена текста в __nano__
Чтобы найти какой-либо текст внутри файла используйте сочетание клавиш __Ctrl+W__, далее введите строку поиска и нажмите __Enter__. Курсор переместится на первое вхождение (относительно курсора) искомого текста. Чтобы продолжить поиск, нажмите сочетание клавиш __option+W__ и курсор переместится к следующему вхождению.
Чтобы найти и заменить какой-либо текст внутри файла, вам потребуется сочетание клавиш __Ctrl+\__. После его нажатия появится запрос на ввод текста который нужно найти и заменить, введите его и нажмите __Enter__. Далее нужно ввести текст на который выходите заменить, введите его и нажмите __Enter__.
Далее режим работы такой, при нажатии клавиши:
__A__ — будет произведена замена всех вхождений искомого текста.
__Y__ — заменить текст около курсора.
__N__ — пропустить и не менять текст около курсора.

- Для поиска использовал комнаду  __Ctrl+W__

Затем ввел слово для поиска в строке __Search (to replace):__

![поиск в nano](/screenshots/part7_13.PNG)

- Для поиска и замены слова использовал сочетание клавиш __Ctrl+\__. В строке __Search (to replace):__ ввожу слово для поиска.

![изменение слова nano](/screenshots/part7_14.PNG)

- Затем в появившемся окне __Replace with:__ ввожу слово или фразу на которую хочу поменять.

![изменение слова nano2](/screenshots/part7_15.PNG)

- Нажав __Enter__ появляется состояние выбора, где я использую клавишу  __Y__.

![изменение слова nano3](/screenshots/part7_16.PNG)

- Данная клавиша __Y__ заменяет текст около курсора.

![изменение слова nano4](/screenshots/part7_17.PNG)


***
## 8. Установка и базовая настройка сервиса sshd.

### Установить службу sshd

- Обновляю системные пакеты __apt__. Для этого  ввожу команды `sudo apt update` и `sudo apt upgrade`;
- Устанавливаю __SSH-сервер__ командами `sudo apt-get install ssh` и `sudo apt install openssh-server`. После установки пакета сервера __SSH__ __`SSH Daemon`__ (сервер __`SSH`__) будет запущен;
- Проверяю состояние SSH-сервера, выполнив команду `sudo systemctl status sshd`.

![служба SSHd](/screenshots/part8_1.PNG)

### Добавить автостарт службы при загрузке системы

- Для включения автостарта службы __`ssh`__ использую команду `sudo systemctl enable ssh`.

![автостарт SSH](/screenshots/part8_2.PNG)

### Перенастроить службу SSHd на порт 2022

- Чтобы изменить порт, необходимо внести изменения в конфиг. Для этого нужно отредактировать файл с помощью команды `sudo nano /etc/ssh/sshd_config`
- В открывшемся файле раскомментирую строку __#Port 22__ и изменяю на __Port 2022__.

![меняем порт на 2022](/screenshots/part8_3.PNG)

- Перезапускаю службу командой `sudo systemctl restart sshd`;
- Перепроверяю измененый порт командой `sudo systemctl status sshd`.

![отображение порта 2022](/screenshots/part8_4.PNG)

### Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи

- Утилита ps одна из самых простых и в то же время часто используемых программ для просмотра списка процессов в Linux. Она не поддерживает интерактивный режим, зато имеет множество опций для настройки вывода тех или иных параметров процессов в Linux.
Чтобы понять, что отображает команда ps, сначала надо разобраться, что такое процесс. Процесс Linux - это экземпляр программы, запущенный в памяти. Все процессы можно разделить на обычные и фоновые. Более подробно об этом написано в статье управление процессами Linux. 
Linux - это многопользовательская система, каждый пользователь может запускать одни и те же программы, и даже один пользователь может запустить несколько экземпляров одной программы, поэтому ядру нужно как-то идентифицировать такие однотипные процессы. Для этого каждому процессу присваивается PID (Proccess Identificator).
__Запуск__ - процесс либо уже работает, либо готов к работе и ждет, когда ему будет дано процессорное время;
__Ожидание__ - процессы в этом состоянии ожидают какого-либо события или освобождения системного ресурса. Ядро делит такие процессы на два типа - те, которые ожидают освобождения аппаратных средств и приостановление с помощью сигнала;
__Остановлено__ - обычно в этом состоянии находятся процессы, которые были остановлены с помощью сигнала;
__Зомби__ - это мертвые процессы, они были остановлены и больше не выполняются, но для них есть запись в таблице процессов, возможно, из-за того, что у процесса остались дочерние процессы.
- Команда `ps` в Linux.
Сначала рассмотрим общий синтаксис команды:

```bash
ps опции
ps опции | grep параметр
```

Во втором варианте мы используем утилиту grep для того, чтобы отобрать нужные нам процессы по определенному критерию. Теперь рассмотрим опции утилиты. Они делятся на два типа - те, которые идут с дефисом Unix и те, которые используются без дефиса - BSD. Лучше пользоваться только опциями Unix, но мы рассмотрим и одни и другие. Заметьте, что при использовании опций BSD, вывод утилиты будет организован в BSD стиле.
__-A, -e, (a)__ - выбрать все процессы;
__-a__ - выбрать все процессы, кроме фоновых;
__-d, (g)__ - выбрать все процессы, даже фоновые, кроме процессов сессий;
__-N__ - выбрать все процессы кроме указанных;
__-С__ - выбирать процессы по имени команды;
__-G__ - выбрать процессы по ID группы;
__-p, (p)__ - выбрать процессы PID;
__--ppid__ - выбрать процессы по PID родительского процесса;
__-s__ - выбрать процессы по ID сессии;
__-t, (t)__ - выбрать процессы по tty;
__-u, (U)__ - выбрать процессы пользователя.
__-x__ - найти все вхождения строки поиска.

- Опции форматирования:
__-с__ - отображать информацию планировщика;
__-f__ - вывести максимум доступных данных, например, количество потоков;
__-F__ - аналогично -f, только выводит ещё больше данных;
__-l__ - длинный формат вывода;
__-j, (j)__ - вывести процессы в стиле Jobs, минимум информации;
__-M, (Z)__ - добавить информацию о безопасности;
__-o, (o)__ - позволяет определить свой формат вывода;
__--sort, (k)__ - выполнять сортировку по указанной колонке;
__-L, (H)__ - отображать потоки процессов в колонках LWP и NLWP;
__-m, (m)__ - вывести потоки после процесса;
__-V, (V)__ - вывести информацию о версии; 
__-H__ - отображать дерево процессов;

- Использую команду для вывода: `ps -aux | grep ssh`

![ключ вывод процесса ssh](/screenshots/part8_5.PNG)

### Перезагрузить систему

- Вывод команды netstat -tan должен содержать  

```bash
tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN
```
- Перезагружаю систему с помощью комануды `sudo reboot`. Устанавливаю программу __netstat__ командой `sudo apt install net-tools`.

![установка netstat](/screenshots/part8_6.PNG)

- __netstat__ (network statistics) — утилита командной строки, выводящая на дисплей состояние TCP-соединений (как входящих, так и исходящих), таблицы маршрутизации, число сетевых интерфейсов и сетевую статистику по протоколам. Доступна в операционных системах семейства UNIX и Windows. Основное назначение утилиты — поиск сетевых проблем и определение производительности сети. 

- Синтаксис

```bash
netstat [-Aan] [-f семейство_адресов] [-I интерфейс] [-p имя_протокола] [система] [core] 
netstat [-n] [-s] [-i | -r] [-f семейство_адресов] [-I интерфейс] [-p имя_протокола] [система] [core] 
netstat [-n] [-I интерфейс] интервал [система] [core]
```
- Опции.
  __-a__ - Показывать состояние всех сокетов. Обычно сокеты, используемые серверными процессами, не показываются;
  __-A__ - Показывать адреса любых управляющих блоков протокола, связанных с сокетами. Используется для отладки;
  __-b__	- Отображение исполняемого файла, участвующего в создании каждого подключения, или ожидающего порта. Иногда известные исполняемые файлы содержат множественные независимые компоненты. Тогда отображается последовательность компонентов, участвующих в создании подключения, либо ожидающий порт. В этом случае имя исполняемого файла находится снизу в скобках [ ], сверху - компонент, который им вызывается, и так до тех пор, пока не достигается TCP/IP. Заметьте, что такой подход может занять много времени и требует достаточных разрешений;
  __-i__	- Показывать состояние автоматически сконфигурированных (auto-configured) интерфейсов. Интерфейсы, статически сконфигурированные в системе, но не найденные во время загрузки, не показываются;
  __-n__	- Показывать сетевые адреса как числа. `netstat` обычно показывает адреса как символы. Эту опцию можно использовать с любым форматом показа.
  __-r__	- Показать таблицы маршрутизации. При использовании с опцией `-s` показывает статистику маршрутизации;
  __-s__	 - Показать статистическую информацию по протоколам. При использовании с опцией `-r` показывает статистику маршрутизации;
  __-f__  - Ограничить показ статистики или адресов управляющих блоков только указанным семейством_адресов, в качестве которого можно указывать:
`inet` - для семейства адресов AF_INET, или unix для семейства адресов AF_UNIX;
  __-I__ - Выделить информацию об указанном интерфейсе в отдельный столбец. По умолчанию (для третьей формы команды) используется интерфейс с наибольшим объёмом переданной информации с момента последней перезагрузки системы. В качестве интерфейса можно указывать любой из интерфейсов, перечисленных в файле конфигурации системы, например, `emd1` или `lo0`.
  __-p__	 - Отобразить идентификатор/название процесса, создавшего сокет (-p, --programs display PID/Program name for sockets).

- __TCP/IP__ — сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю.
  - __proto__ - название порта.
  - __Local address__ - локальный адрес.
  - __Foreign address__ - внешний адрес, учавствующий в создании соединения.
  - __State__ - состояние соединения, все варианты.
  - __CLOSE_WAIT__ - ожидание закрытия соединения.
  - __CLOSED__ - соединение закрыто.
  - __ESTABLISHED__ - соединение установлено.
  - __LISTENING__ - ожидается соединение (слушается порт).
  - __TIME_WAIT__ - превышение времени ответа.

- `Адрес 0.0.0.0` означает «любой IP данного компьютера» и включает в себя в том числе 127.0.0.1. Адрес 0.0.0.0 обычно означает, что IP адрес ещё не настроен или не присвоен. Такой адрес указывает хост, который обращается к __DHCP__ для получения `IP адреса`.

### Вывод команды `netstat -tan`

![вывод tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN](/screenshots/part8_7.PNG)


***
## 9. Установка и использование утилит top, htop

### Установить и запустить утилиты top и htop.
- Опций запуска у команды немного и использовать их активно не принято, потому что большинство действий выполняются с помощью интерактивных команд. Вот основные опции:
  - __-v__ — вывести версию программы;
  - __-b__ — режим только для вывода данных, программа не воспринимает интерактивных команд и выполняется пока не будет завершена вручную;
  - __-c__ — отображать полный путь к исполняемым файлам команд;
  - __-d__ — интервал обновления информации;
  - __-H__ — включает вывод потоков процессов;
  - __-i__ — не отображать процессы, которые не используют ресурсы процессора;
  - __-n__ — количество циклов обновления данных, после которых надо закрыть программу;
  - __-o__ — поле, по которому надо выполнять сортировку;
  - __-O__ — вывести все доступные поля для сортировки;
  - __-p__ — отслеживать только указанные по PID процессы, можно указать несколько PID;
  - __-u__ — выводить только процессы, запущенные от имени указанного пользователя.

- Интерактивные команды, которые вы можно выполнять во время работы программы.
  - __h__ — вывод справки по утилите;
  - __q__ или __Esc__ — выход из `top`;
  - __A__ — выбор цветовой схемы;
  - __d__ или __s__ — изменить интервал обновления информации;
  - __H__ — выводить потоки процессов;
  - __k__ — послать сигнал завершения процессу;
  - __W__ — записать текущие настройки программы в конфигурационный файл;
  - __Y__ — посмотреть дополнительные сведения о процессе, открытые файлы, порты, логи и т д;
  - __Z__ — изменить цветовую схему;
  - __l__ — скрыть или вывести информацию о средней нагрузке на систему;
  - __m__ — выключить или переключить режим отображения информации о памяти;
  - __x__ — выделять жирным колонку, по которой выполняется сортировка;
  - __y__ — выделять жирным процессы, которые выполняются в данный момент;
  - __z__ — переключение между цветным и одноцветным режимами;
  - __c__ — переключение режима вывода команды, доступен полный путь и только команда;
  - __F__ — настройка полей с информацией о процессах;
  - __o__ — фильтрация процессов по произвольному условию;
  - __u__ — фильтрация процессов по имени пользователя;
  - __V__ — отображение процессов в виде дерева;
  - __i__ — переключение режима отображения процессов, которые сейчас не используют ресурсы процессора;
  - __n__ — максимальное количество процессов, для отображения в программе;
  - __L__ — поиск по слову;
  - __<>__ — перемещение поля сортировки вправо и влево;
Это далеко не все команды top, но их будет вполне достаточно для начала работы, а остальные вы сможете найти в официальной документации по утилите.

### Запуск программы

- Для установки программы использую команду `sudo apt install top`. Затем для запуска просто выполняю команду `top`.
Окно можно условно разделить на две части. В верхней части находится информация о системе, общем использовании ресурсов процессора и памяти, раздела подкачки, и так далее. В нижней части окна расположен список запущенных процессов с информацией, отсортированных по определённому полю.
Если все процессы не помещаются на одном экране, их можно листать с помощью стрелок вверх и вниз. Если не помещаются все колонки — с помощью стрелок вправо и влево.
Если не помещаются все колонки - с помощью стрелок вправо и влево.

- __uptime__ - время последней перезагрузки. Для запуска использовал команду `uptime`.

![uptime](/screenshots/part9_1.PNG)

- Вывод команды `top`.

![uptime](/screenshots/part9_2.PNG)

- Слева вверху указано текущее время системы, далее:
  - __up__ — время работы системы с последнего запуска. -> 12 min
  - __user__ — количество текущих пользователей. -> 1 user
  - __load average__ — средняя нагрузка на сервер: отображаются значения за 1, 5 , 15 минут назад. ->0.01, 0.12, 0.15
  - __Tasks__ — общее количество запущенных процессов в разных статусах (running — выполняемые; sleeping — в ожидании; stopped — остановленные; zombie — «зомби», дочерние процессы, ожидающие завершения родительского процесса). -> 112 total, 1 running, 110 sleeping, 1 stopped, 0 zombie
  - __Cpu(s)__ — процент времени процессора, затраченного на выполнение процессов, в том числе:
  - __us__ — пользовательские процессы (высокое значение данного показателя может указывать, в том числе, на проблемы в коде сайта, необходимость его оптимизации); -> 0.0
  - __sy__ — процессы ядра; -> 0.7
  - __id__ — неиспользуемые ресурсы (чем выше этот показатель, тем лучше); -> 99.3
  - __wa__ — операции ввода/вывода, т.е. дисковые операции. -> 0.0
  - __Mem, Swap__ — сведения об использовании оперативной памяти (total — общий объем, free — объем свободной памяти, used — объем использованной памяти). -> Mem total 391.8, Mem free 2877.2, Mem used 204.3, Swap total 2948.0, Swap free 2948.0, Swap used 0.0

- Команда (утилита) __w__ — отображает информацию о пользователях которые в настоящее время есть на машине, и их процессов. Внутри заголовка, показывается текущее время, как долго система работает, сколько пользователей в настоящее время вошли в систему, и среднюю нагрузку системы за последние 1, 5, 15 минут.

- Прописываю команду `w`.

![комманда w](/screenshots/part9_3.PNG)

- Аналогично утилите `top`, можно использовать `htop`, что намного проще. Пользовательский интерфейс программы `htop` основан на Ncurses. Представление информации действительно чистое. С помощью этого инструмента можно фильтровать, управлять и делать другие интересные вещи, связанные с процессами, запущенными в системе. Это отличный инструмент для системных администраторов Gnu / Linux.

- Запускаю команду `htop`

![htop](/screenshots/part9_4.PNG)

Обозначения столбцов:
- __PID__ — идентификатор процесса;
- __USER__ — пользователь, запустивший процесс;
- __PR__ — приоритет процесса;
- __NI__ — измененный приоритет (присвоенный пользователем с помощью команды nice);
- __VIRT__ — объем используемой виртуальной памяти (здесь выводится тот объем памяти, который был запрошен процессом, даже если фактически используется меньше);
- __RES__ — объем используемой оперативной памяти
- __SHR__ — объем памяти, разделяемой с другими процессами (т.е. память, которая может быть использована другими процессами);
- __S__ — статус процесса (running — запущен; sleeping — в ожидании; zombie — процесс-«зомби»)
- __D__ - бесперебойный сон;
- __I__ - простой (не работает);
- __R__ - запущен;
- __S__ - спит;
- __T__ - остановлен сигналом управления работой;
- __t__ - остановлен отладчиком во время трассировки;
- __Z__ - зомби.
- __%CPU__ — процент использования процессорного времени;
- __%MEM__ — процент использования оперативной памяти;
- __TIME__ — общее время работы процесса;
- __COMMAND__ — имя процесса (команда, которой был запущен процесс).

- Для управления сортировкой используются клавиши __M__ (сортировка по памяти), __P__ (по процессору), __T__ (по времени), аналогично утилите `top`. Так же можно воспользоваться клавишей __F6 -> SortBy__.
При нажатии клавиши __F6__ экран сменится и будет предоставлен выбор вариантов сортировки. Выбираем необходимый вариант с помощью стрелок ввер, вниз и нажимаем enter.

![F6 сортировка htop](/screenshots/part9_5.PNG)

- Сортировка по  __PID__

![сортировка по PID](/screenshots/part9_6.PNG)

- Сортировка по __PERCENT_CPU__

![сортировка по Percent_CPU](/screenshots/part9_7.PNG)

- Сортировка по __PERCENT_MEM__

![Сортировка по PERCENT_MEM](/screenshots/part9_8.PNG)

- Сортировка по __TIME__

![Сортировка по TIME](/screenshots/part9_9.PNG)
  
- Выполняю фильтрации по процессу `sshd`.
Использую клавишу __F4 -> Filter__.

- Процесс __sshd__

![процесс sshd](/screenshots/part9_10.PNG)

- Для поиска процесса `syslog` необходимо отключить предыдущую настройку фильтрации.
Затем воспользоваться клавишей __F3 -> Search__.

![вывод syslog](/screenshots/part9_11.PNG)

- Нажав клавишу __F2 -> Setup__, перемещаюсь клавишей `->` вправа для добавления пунктов hostname, clock и uptime в панель вывода.
Данная панель появляется автоматически в правом верхнем углу, либо можно добавить в левый угол на выбор.

![добавление hostname, clock и uptime](/screenshots/part9_12.PNG)


***
## 10. Использование утилиты fdisk

### Запустить команду __fdisk -l
- Синтаксис утилиты ничем не отличается от других команд Linux `fdisk опции устройство`. __fdisk__ надо передать опции, согласно действия, которое вы хотите 
выполнить, а также раздел диска или устройство к которому эти действия надо применить.

- Опции __fdisk__:
  - __-B__, __--protect-boot__ - не стирать первые 512 байт диска, чтобы не повредить загрузочную запись;
  - __-L, --color__ - настройка цветного вывода, возможные значения auto, never или always;
  - __-l, --list__ - вывести все разделы на выбранных устройствах или если устройств не задано, то на всех устройствах;
  - __-o, --output__ - указывает какие поля данных надо показывать в выводе программы, доступные поля рассмотрим ниже;
  - __-u, --units__ - настраивает формат вывода размера разделов, доступные значения: cylinders, sectors, по умолчанию используется sectors;
  - __-w, --wipe__ - режим стирания файловой системы или RAID с диска, возможные значения auto, never или always по умолчанию используется auto;
  - __-W, --wipe-partition__ - режим стирания файловой системы или RAID из только что созданного раздела. Возможные значения аналогичны предыдущей опции;
  - __-h, --help__ - показать справку по утилите;
  - __-v, --version__ - опция выводит версию утилиты.

- Команды __fdisk__:
  - __a__ - включение или выключения флага boot для раздела;
  - __d__ - удалить раздел;
  - __F__ - показать свободное место;
  - __l__ - вывести список известных типов разделов;
  - __n__ - создать новый раздел;
  - __p__ - вывести таблицу разделов;
  - __t__ - изменение типа раздела;
  - __i__ - вывести информацию о разделе;
  - __I__ и __O__ - записать или загрузить разметку в файл сценария sfdisk;
  - __w__ - записать новую таблицу разделов на диск;
  - __q__ - выйти без сохранения;
  - __g__ - создать пустую таблицу разделов GPT;
  - __o__ - создать пустую таблицу разделов MBR.

- Использую команду `sudo fdisk -l`

![вывод команды sudo fdisk -l](/screenshots/part10.PNG)

- Название жёсткого диска - sda;
- Размер жёсткого диска - 30GiB;
- Количество секторов - 62914560;
- При созданий виртуальной машины swap не создавался.


***
## 11. Использование утилиты df

### Запустить команду df.

- Утилита __df__ поставляется по умолчанию во всех дистрибутивах Linux и имеет очень простой синтаксис. Фактически вы можете просто набрать `df` и уже получить результат, но чтобы сделать вывод более читаемым используются дополнительные опции. Вот основной синтаксис `df [опции] [устройство]`.
Устройство указывать необязательно, но можно указать раздел диска, о котором мы хотим посмотреть информацию. 

- Основные опции утилиты:
  - __-a, --all__ - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные;
  - __-B__ - изменить размер одного блока перед выводом данных, например, можно использовать __BM__, чтобы вывести все данные в мегабайтах;
  - __-h__ - выводить размеры в читаемом виде, в мегабайтах или гигабайтах;
  - __-H__ - выводить все размеры в гигабайтах;
  - __-i__ - выводить информацию об inode;
  - __-k__ - выводить размеры в килобайтах;
  - __--output__ - использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: `'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail', 'pcent', 'file' , 'target';`
  - __-P__ - использовать формат вывода __POSIX__;
  - __--total__ - выводить всю информацию про использованное и доступное место;
  - __-t__, __--type__ - выводить информацию только про указанные файловые системы;
  - __-x__ - выводить информацию обо всех, кроме указанных файловых систем.

Утилита отображает стандартный набор колонок, но понять в ее выводе что-то с первого раза сложно. Все данные выводятся в килобайтах. 

Для вывода данных в более читаемом виде использую команду `sudo df`.

![sudo df](/screenshots/part11_1.PNG)

- Размер корневого раздела - 14339080. (Данные выводятся в килобайтах.)
- Размер занятого пространства - 6133968. (Данные выводятся в килобайтах.)
- Размер свободного пространства - 7454932. (Данные выводятся в килобайтах.)
- Процент использования - 46%.

- Запустить команду __df -Th__ `sudo df -Th`

![вывод команды sudo df -Th](/screenshots/part11_2.PNG)

- Размер корневого раздела - 14G. (Данные выводятся в гигабайтах.)
- Размер занятого пространства - 5.9G. (Данные выводятся в гигабайтах.)
- Размер свободного пространства - 7.2G. (Данные выводятся в гигабайтах.)
- Процент использования - 46%.
    
Мы видим, что используется файловая система ext4. Ext4 — журналируемая файловая система, предлагаемая для использования по умолчанию инсталятором Ubuntu, начиная с версии 9.10.


***
## 12. Использование утилиты du

### Запустить команду du

- Синтаксис команды __du__ не сложный. 
Достаточно передать ей опции и путь к папке, с которой нужно работать `du опции /путь/к/папке`

- Oпции утилиты __du__:
  - __-a, --all__ - выводить размер для всех файлов, а не только для директорий, по умолчанию размер выводится только для папок;
  - __-B, --block-size__ - указать единицы вывода размера, доступно: `K,M,G,T,P,E,Z,Y` для 1024 и KB, MB и так далее для 1000;
  - __-c, --total__ - выводить в конце общий размер всех папок;
  - __-d, --max-depth__ - максимальная глубина вложенности директорий;
  - __-h, --human-readable__ - выводить размер в единицах измерения удобных для человека;
  - __--inodes__ - выводить информацию об использованию inode;
  - __-L, --dereference__ - следовать по всем символическим ссылкам;
  - __-l, --count-links__ - учитывать размер файла несколько раз для жестких ссылок;
  - __-P, --no-dereference__ - не следовать по символическим ссылкам, это поведение используется по умолчанию;
  - __-S, --separate-dirs__ - не включать размер подпапок в размер папки;
  - __--si__ - выводить размер файлов и папок в системе СИ, используется 1000 вместо 1024;
  - __-s, --summarize__ - выводить только общий размер;
  - __-t, --threshold__ - не учитывать файлы и папки с размером меньше указанного;
  - __--time__ - отображать время последней модификации для файла или папки, вместо времени модификации можно выводить такие метки: atime, access, use, ctime;
  - __-X, --exclude__ - исключить файлы из подсчёта;
  - __-x, --one-file-system__ - пропускать примонтированные файловые системы;
  - __--version__ - вывести версию утилиты.

- Выполняю команду `sudo du`

![sudo du](/screenshots/part12_1.PNG)

### Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)

- Ввожу команды `cd` и `du home`

![du home](/screenshots/part12_2.PNG)

- Ввожу команду `sudo du -h home`

![du -h home](/screenshots/part12_3.PNG)

- Ввожу команду `sudo du var`

![du var](/screenshots/part12_4.PNG)

- Ввожу команду `sudo du -h var` 

![du -h var](/screenshots/part12_5.PNG)

- Ввожу команду `sudo du var/log`

![du var/log](/screenshots/part12_6.PNG)

- Ввожу команду `sudo du -h var/log`

![du -h var/log](/screenshots/part12_7.PNG)

### Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя *)

-  Ввожу команду `sudo du -h var/log/*`

![du -h var/log/*](/screenshots/part12_8.PNG)


***
## 13. Установка и использование утилиты ncdu

### Установить утилиту ncdu

- __ncdu__ (NCurses Disk Usage) является инструментом командной строки для просмотра и анализа использования дискового пространства на Linux. Он может показать древовидные каталоги и дать отчет о свободном пространстве на нашем диске, используемого в отдельных каталогах. Таким образом, очень легко отследить сколько занимает места файлы / каталоги. Он на самом деле позволяет пользователю сделать это гораздо быстрее, чем менеджеры с графическим интерфейсом. __ncdu__ доступен по умолчанию в Ubuntu, Linux Mint и в репозитории Debian.

- Устанавливаю __ncdu__, выполнив команду `sudo apt install ncdu`

![install ncdu](/screenshots/part13_1.PNG)

### Вывести размер папок /home, /var, /var/log
  - Для этого ввожу команду `ncdu /home`

![ncdu home](/screenshots/part13_2.PNG)

  - Затем `ncdu /var`

![ncdu var](/screenshots/part13_3.PNG)

  - Затем `ncdu /var/log`

![ncdu var/log](/screenshots/part13_4.PNG)


***
## 14. Работа с системными журналами

### Открыть для просмотра:

__/var/log/dmesg__

- Использую команду `vim /var/log/dmesg`

![dmesg](/screenshots/part14_1.PNG)

__/var/log/syslog__

- Использую команду `vim /var/log/syslog`

![syslog](/screenshots/part14_2.PNG)

__/var/log/auth.log__

- Использую команду `sudo vim /var/log/auth.log`

![auth.log](/screenshots/part14_3.PNG)

Большинство лог файлов содержится в директории __/var/log__:
- `/var/log/syslog` или `/var/log/messages` содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux, различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.
- `/var/log/auth.log` или `/var/log/secure` — информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему, а также задействованные механизмы аутентификации.
- `/var/log/dmesg` — драйвера устройств. Одноименной командой можно просмотреть вывод содержимого файла. Размер журнала ограничен, когда файл достигнет своего предела, старые сообщения будут перезаписаны более новыми. Задав ключ `--level=` можно отфильтровать вывод по критерию значимости.
- `/var/log/alternatives.log` — Вывод программы `update-alternatives`, в котором находятся символические ссылки на команды или библиотеки по умолчанию.
- `/var/log/anaconda.log` — Записи, зарегистрированные во время установки системы.
- `/var/log/audit` — Записи, созданные службой аудита __auditd__.
- `/var/log/boot.log` — Информация, которая пишется при загрузке операционной системы.
- `/var/log/cron` — Отчет службы __crond__ об исполняемых командах и сообщения от самих команд.
- `/var/log/cups` — Все, что связано с печатью и принтерами.
- `/var/log/faillog` — Неудачные попытки входа в систему. Очень полезно при проверке угроз в системе безопасности, хакерских атаках, попыток взлома методом перебора. Прочитать содержимое можно с помощью команды __faillog__.
- `var/log/kern.log` — Журнал содержит сообщения от ядра и предупреждения, которые могут быть полезны при устранении ошибок пользовательских модулей встроенных в ядро.
- `/var/log/maillog/` или `/var/log/mail.log` — Журнал почтового сервера, используемого на ОС.
- `/var/log/pm-powersave.log` — Сообщения службы экономии заряда батареи.
- `/var/log/samba/` — Логи файлового сервера __Samba__, который используется для доступа к общим папкам Windows и предоставления доступа пользователям Windows к общим папкам Linux.
- `/var/log/spooler` — Для представителей старой школы, содержит сообщения __USENET__. Чаще всего бывает пустым и заброшенным.
- `/var/log/Xorg.0.log` — Логи __X__ сервера. Чаще всего бесполезны, но если в них есть строки начинающиеся с EE, то следует обратить на них внимание.

Для каждого дистрибутива будет отдельный журнал менеджера пакетов.

- `/var/log/yum.log` — Для программ установленных с помощью Yum в RedHat Linux.
- `/var/log/emerge.log` — Для `ebuild-ов` установленных из Portage с помощью emerge в Gentoo Linux.
- `/var/log/dpkg.log` — Для программ установленных с помощью __dpkg__ в Debian Linux и всем семействе родственных дистрибутивах.

И немного бинарных журналов учета пользовательских сессий

- `/var/log/lastlog` — Последняя сессия пользователей. Прочитать можно командой last.
- `/var/log/tallylog` — Аудит неудачных попыток входа в систему. Вывод на экран с помощью утилиты __pam_tally2__.
- `/var/log/btmp` — Еже один журнал записи неудачных попыток входа в систему. Просто так, на всякий случай, если вы еще не догадались, где следует искать следы активности взломщиков.
- `/var/log/utmp` — Список входов пользователей в систему на данный момент.
- `/var/log/wtmp` — Еще один журнал записи входа пользователей в систему. Вывод на экран командой __utmpdump__.

### Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему

- Синтаксис и опции __last__.
Данная утилита по умолчанию берет данные из файла `/var/log/wtmp` и выводит полный список пользователей, вошедших в систему и вышедших. Рассмотрим ее синтаксис. В терминале нужно задать опции, имя одного или нескольких пользователей и __tty__:
`$ last опции имя_пользователя название_tty`
Вместо last можно использовать __lastb__. В таком случае по умолчанию будет использоваться файл `/var/log/btmp`, в котором сохранены все неудачные попытки входа. 

Теперь пройдемся по доступным опциям:
- `-a`, `--hostlast` – выводить информацию об имени хоста (hostname) в последнем столбце. Изначально она отображается в третьем столбце.
- `-d`, `--dns` – выводить IP-адрес пользователя в случае удаленного подключения. Удобно использовать вместе с предыдущей опцией.
- `-f`, `--file` – выбрать свой файл для загрузки данных вместо используемого по умолчанию `/var/log/wtmp`. Опцию можно использовать несколько раз, выбрав два и более файла.
- `-F`, `--fulltimes` – выводить полные дату и время входов и выходов из системы.
- `-i`, `--ip` – выводить IP-адрес пользователя при удаленном подключении вместо имени хоста. Это несколько похоже на упомянутую ранее опцию __--dns__.
- `-число`, `-n`, `--limit` – указать, сколько строк информации будет выведено при выполнении команды.
- `-p`, `--present` – выводить информацию о сессиях в конкретное время.
- `-R`, `--nohostname` – не отображать графу с именем хоста.
- `-s`, `--since` – выводить информацию начиная с указанного момента времени.
- `-t`, `--until` – выводить информацию до указанного времени.
- `--time-format` – выбрать один из 4 доступных способов отображения времени: notime – вообще не выводить информацию, short – стандартный вариант, использующийся по умолчанию, full – полная информация, как в случае с опцией `--fultimes`, iso – использовать формат ISO-8601, включающий в себя часовой пояс.
- `-w`, `--fullname` – выводить полные имена пользователей и доменов.
- `-x`, `--system` – отображать записи о выключении системы и изменении уровня выполнения (run level).

Главная задача – получить полную информацию для всех пользователей. Для этих целей команде last нужно передать опции __-F, -w , -x__: (вывод команды записываем в создаваемый нами файл для удобства просмотра любым из установленных текстовых редакторов)

Использую команды `sudo -s`, `last -F -w -x >> test.txt` и `mcedit test.txt`

![вывод команды last](/screenshots/part14_4.PNG)

- Сначала идет имя пользователя. Обратите внимание, что reboot – это отдельный пользователь, появляющийся во время перезагрузки, shutdown – при выключении, runlevel – при изменении уровня выполнения.
- Информация о tty сессии.
- Имя хоста.
- Время входа.
- Время выхода.
- Продолжительность сессии.
  
В данном случае мы видим:
-  Время последне успешной авторизации -> Wed Mar 1 14:45:36 2023;
-  Имя пользователя -> lemuelge;
-  Метод входа в систему -> tty1.

- Прежде чем идти дальше, мы посмотрим, что такое __TTY__.
Как упоминалось в ответе на форуме AskUbuntu, слово TTY появилось из TeleTYpewriter.
Еще в ранние дни Unix пользовательские терминалы, подключенные к компьютерам, были электромеханическими телепринтерами или телетайпами (tty вкратце).
С тех пор имя TTY продолжает использоваться для консолей с текстом. В настоящее время все текстовые консоли представляют собой виртуальные консоли, а не физические консоли. Команда TTY печатает имя файла терминала, подключенного к стандартному входу.
Переключение между TTY в Linux
По умолчанию в Linux есть 7 tty.
Они известны как tty1, tty2 … .. tty7.
От 1 до 6 tty – только командная строка.
7th tty – графический интерфейс (ваш рабочий стол X).
Вы можете переключаться между различными TTY, используя клавиши CTRL + ALT + Fn, для MAC OS option + стрелка влево/вправо.

### Перезапустить службу sshd

- Команда __systemctl__ довольно хорошо известна среди пользователей Linux, когда речь идет о включении, отключении, остановке и запуске любой службы. Итак, мы сначала использовали команду systemctl, чтобы включить сервер ssh. Ключевым здесь является слово `enable`, наряду с ключевым словом `ssh`. Он включит ssh-сервер, синхронизировав скрипт sysv. 

Ввожу команду ` sudo systemctl enable ssh`

![enable ssh](/screenshots/part14_5.PNG)

- Теперь сервер __ssh__ включен и готов к запуску. Таким образом, команда `systemctl` будет использоваться еще раз для запуска службы ssh. После запуска службы __ssh__ мы должны проверить, правильно ли она активна и работает. Для этого снова использовался тот же `systemctl`. В обеих командах есть разница только в одном слове, `start и status`. Вывод показывает, что служба Openssh в настоящее время активна и работает правильно.

Ввожу команды `sudo systemctl start ssh` и `sudo systemctl status ssh`

![status ssh](/screenshots/part14_6.PNG)

- Чтобы проверить статус службы __ssh__, вы также можете использовать ключевое слово `sshd` вместо `ssh`.

Ввожу команду `sudo systemctl status sshd`

![status sshd](/screenshots/part14_7.PNG)

### Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах)

Рестарт службы можно найти в логах по адресу `/var/log/auth.log`.

Для легкой читаемости ввожу команды `sudo -s` и `tail -f /var/log/auth.log`

![перезапуск sshd](/screenshots/part14_8.PNG)


***
## 15. Использование планировщика заданий CRON

### Используя планировщик заданий, запустите команду uptime через каждые 2 минуты

- CRON уже установлен в моей системе по этому перехожу сразу к настройки.
В случае отсутсвия __CRON__ используются команды `sudo apt install cron`

![cron](/screenshots/part15_1.PNG)

Для запуска __cron__ в фоновом режиме использую команду `sudo systemctl enable cron`

![cron enable](/screenshots/part15_2.PNG)

- Системным администраторам, да и обычным пользователям часто приходится автоматизировать различные задачи по обслуживанию и работе с Linux с помощью скриптов. Это очень удобно, вы просто запускаете скрипт, и он делает все что необходимо без вашего вмешательства. Следующий шаг в этом пути - настроить автоматически запуск нужного скрипта в нужное время. 
Именно для этих задач в Linux используется системный сервис cron. Это планировщик, который позволяет выполнять нужные вам скрипты раз в час, раз в день, неделю или месяц, а также в любое заданное вами время или через любой интервал. Программа часто используется даже другими службами операционной системы. 
Фактически, __Cron__ - это сервис, как и большинство других сервисов Linux, он запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл `/etc/crontab`, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты __run-parts__, которая запускает нужные скрипты из следующих папок:

```bash
/etc/cron.minutely - каждую минуту;
/etc/cron.hourly - каждый час;
/etc/cron.daily - каждый день;
/etc/cron.weekly - каждую неделю;
/etc/cron.monthly - каждый месяц.
```

- В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле __crontab__ прописан запуск команды __anacron__, которая работает так же как и cron, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.
Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл `/var/spool/anacron`, а затем, при следующем запуске __anacron__ проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.

### Настройка cron

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла __cron__ и специальная команда. Конечно, вы всегда можете отредактировать файл `/etc/crontab`, но этого делать не рекомендуется. Вместо этого, есть команда __crontab__ `sudo crontab -e`
При выполнении команды будет дан выбор текстого редактора дял внесения изменений. Я воспользовался __mcedit__. __crontab__ открывает временный файл, в котором уже представлены все текущие правила __cron__ и вы можете добавить новые. После завершения работы команды cron файл будет обработан и все правила будут добавлены в `/var/spool/cron/crontabs/имя_пользователя` причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.
Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и crontab нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

![crontab -e](/screenshots/part15_3.PNG)

- Синтаксис __crontab__.
Как я уже говорил, время задается особым синтаксисом. Давайте рассмотрим синтаксис настройки одной задачи cron
`минута час день месяц день_недели /путь/к/исполняемому/файлу`
Нужно сказать, что обязательно нужно писать полный путь к команде, потому что для команд, запускаемых от имени cron переменная среды __PATH__ будет отличаться, и сервис просто не сможет найти вашу команду. Это вторая самая распространенная причина проблем с Cron. Дата и время указываются с помощью цифр или символа __'*'__. Этот символ означает, что нужно выполнять каждый раз, если в первом поле - то каждую минуту и так далее.
Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, раз в 2 минуты. Для этого используется разделитель косая черта - __"/"__:
`*/2 * * * * /usr/local/bin/serve`
Для формирования отчёта данные по работе команды __uptime__ буду записывать в файл __cron.txt__

![cron редактирование](/screenshots/part15_4.PNG)

- __uptime.__
Синтаксис для команды uptime следующий: `uptime [OPTIONS]`
Чтобы отобразить время работы системы, вызовите команду без каких-либо опций `uptime`
Вывод будет выглядеть примерно так:
18:04:00 up 3:20, 1 user, load average: 0.00, 0.00, 0.00
- 18:04:00 — текущее системное время.
- up 3:20 — это время, в течение которого система работала.
- 1 user количество зарегистрированных пользователей.
- load average: 0.00, 0.00, 0.00 — средние значения загрузки системы за последние 1, 5 и 15 минут.

Средняя нагрузка на Linux может немного сбивать с толку. В отличие от других операционных систем, которые показывают средние значения загрузки процессора, Linux показывает средние значения загрузки системы.
Средняя загрузка системы измеряет количество заданий, которые в данный момент выполняются или ожидают дискового ввода-вывода. В основном это говорит о том, насколько занята ваша система в течение заданного интервала.
Если средние значения нагрузки равны 0,0, то система в основном простаивает. Если среднее значение нагрузки за последние 1 минуту выше, чем среднее значение за 5 или 15 минут, то нагрузка увеличивается, в противном случае нагрузка уменьшается. Средняя нагрузка увеличивается из-за более высокой загрузки процессора, нагрузки на диск.

Открываем через некоторое время наш файл __cron.txt__ и видим результат работы команды с интервалом в две минуты.

![cron результат](/screenshots/part15_5.PNG)

- Теперь в системном журнале проверим наличие записей о работе вызовов команды, используя следующую команду с перенаправлением данных в файл __cron_data.txt__
Для этого использую команды  `sudo -s` и `sudo grep CRON /var/log/syslog > cron_data.txt`

![grep CRON /var/log/syslog](/screenshots/part15_6.PNG)

- Удаляю все задания в планировщике заданий `sudo cronetab -e`

![убираю и сохраняю crontab ](/screenshots/part15_7.PNG)